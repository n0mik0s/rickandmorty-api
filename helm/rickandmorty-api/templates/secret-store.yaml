# SecretStore — ESO Kubernetes provider (namespace-scoped)
#
# This is the correct ESO pattern when GitHub Actions is the secret source:
#
#   1. CI pushes the JSON string into a real Kubernetes Secret:
#        kubectl create secret generic eso-source-secret \
#          --from-literal=secrets.json="$RICKANDMORTY_DB_SECRET" \
#          --namespace <namespace> \
#          --dry-run=client -o yaml | kubectl apply -f -
#
#   2. This SecretStore tells ESO to read Kubernetes Secrets in the same
#      namespace using its own ServiceAccount.
#
#   3. The ExternalSecret (externalsecret.yaml) then references this store
#      and maps eso-source-secret[secrets.json] → the application Secret.
#
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: {{ .Values.externalSecrets.secretStore.name }}
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "rickandmorty-api.labels" . | nindent 4 }}
spec:
  provider:
    kubernetes:
      # Read secrets from the same namespace this chart is deployed into
      remoteNamespace: {{ .Release.Namespace }}
      server:
        # Empty server block = use the in-cluster API server
        caProvider:
          type: ConfigMap
          name: kube-root-ca.crt
          key: ca.crt
      auth:
        serviceAccount:
          name: {{ include "rickandmorty-api.serviceAccountName" . }}