name: CI/CD Pipeline

on:
  push:
    branches: [main, master, develop]
  pull_request:
    branches: [main, master]

env:
  REGISTRY: docker.io
  IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/rickandmorty-api
  APP_DIR: .

jobs:
  # ─────────────────────────────────────────────
  # 1. Code Quality
  # ─────────────────────────────────────────────
  lint-and-security:
    name: Lint & Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"

      - name: Set up Python
        run: uv python install

      - name: Install dependencies
        working-directory: ${{ env.APP_DIR }}
        run: uv sync --all-extras

      # Ruff covers both linting and formatting checks
      - name: Lint with Ruff
        working-directory: ${{ env.APP_DIR }}
        run: uv run ruff check . --output-format=github

      - name: Format check with Ruff
        working-directory: ${{ env.APP_DIR }}
        run: uv run ruff format --check .

      # Static type checking
      - name: Type check with mypy
        working-directory: ${{ env.APP_DIR }}
        run: uv run mypy main.py --ignore-missing-imports
        continue-on-error: true   # advisory; flip to false to enforce

      # Security: dependency vulnerabilities
      - name: Security scan with pip-audit
        working-directory: ${{ env.APP_DIR }}
        run: uv run pip-audit

      # Security: source-code patterns (secrets, hardcoded creds, etc.)
      - name: Security scan with Bandit
        working-directory: ${{ env.APP_DIR }}
        run: uv run bandit -r main.py -c pyproject.toml -ll

  # ─────────────────────────────────────────────
  # 2. Unit Tests
  # ─────────────────────────────────────────────
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: lint-and-security

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Set up Python
        run: uv python install

      - name: Install dependencies
        working-directory: ${{ env.APP_DIR }}
        run: uv sync --all-extras

      # Provide dummy config/secret files so the module-level argparse
      # does not fail during import inside the test suite.
      - name: Create dummy config files
        run: |
          mkdir -p tmp
          echo '{"user":"test","password":"test","host":"localhost","dbname":"testdb"}' > tmp/secrets.json
          printf 'log_level: INFO\n' > tmp/config.yaml

      - name: Run unit tests
        working-directory: ${{ env.APP_DIR }}
        env:
          CONFIG_PATH: ../tmp/config.yaml
          SECRET_PATH: ../tmp/secrets.json
        run: |
          uv run pytest tests/unit/ \
            --tb=short \
            -v \
            --cov=main \
            --cov-report=xml \
            --cov-report=term-missing

      - name: Upload coverage report
        uses: codecov/codecov-action@v4
        if: always()
        with:
          files: ${{ env.APP_DIR }}/coverage.xml
          fail_ci_if_error: false

  # ─────────────────────────────────────────────
  # 3. Build & Test Docker Image
  # ─────────────────────────────────────────────
  build-and-test:
    name: Build & Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image (local, no push)
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.APP_DIR }}
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ── Scan the built image for OS/package CVEs ──
      - name: Scan image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_NAME }}:test
          format: table
          exit-code: 1            # fail on CRITICAL vulnerabilities
          severity: CRITICAL
          ignore-unfixed: true

      # ── Spin up the app container for integration tests ──
      - name: Create runtime config files
        run: |
          mkdir -p tmp
          cat > tmp/secrets.json <<'EOF'
          {"user":"testuser","password":"testpass","host":"localhost","dbname":"rickandmorty"}
          EOF
          printf 'log_level: INFO\n' > tmp/config.yaml

      - name: Run application container
        run: |
          docker run -d \
            --name app \
            --network host \
            -v ${{ github.workspace }}/tmp:/tmp/appconfig:ro \
            ${{ env.IMAGE_NAME }}:test \
            --config /tmp/appconfig/config.yaml \
            --secret /tmp/appconfig/secrets.json

      - name: Wait for application to be ready
        run: |
          for i in $(seq 1 30); do
            if curl -sf http://localhost:8000/docs > /dev/null 2>&1; then
              echo "App is up!"
              break
            fi
            echo "Waiting... attempt $i"
            sleep 3
          done

      - name: Install uv (for integration test runner)
        uses: astral-sh/setup-uv@v4

      - name: Set up Python
        run: uv python install

      - name: Install test dependencies
        working-directory: ${{ env.APP_DIR }}
        run: uv sync --all-extras

      - name: Run integration tests
        working-directory: ${{ env.APP_DIR }}
        env:
          API_BASE_URL: http://localhost:8000
          DB_HOST: localhost
          DB_USER: testuser
          DB_PASSWORD: testpass
          DB_NAME: rickandmorty
        run: |
          uv run pytest tests/integration/ \
            --tb=short \
            -v

      - name: Dump container logs on failure
        if: failure()
        run: docker logs app

  # ─────────────────────────────────────────────
  # 4. Push to Docker Hub
  # ─────────────────────────────────────────────
  push-image:
    name: Push to Docker Hub
    runs-on: ubuntu-latest
    needs: build-and-test
    # Only push on commits to the default branch (not on PRs)
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')

    steps:
      #- name: Set current date as environment variable
      #  run: echo "NOW=$(date +'%Y-%m-%d')" >> $GITHUB_ENV

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract Docker metadata (tags & labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: type=raw,value=build-{{date 'YYYYMMDD-HHmm'}}-{{sha}}
          #tags: |
          #  type=sha,prefix=sha-
          #  type=ref,event=branch
          #  type=raw,value=build-${{ env.NOW }},enable=${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' }}

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.APP_DIR }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

# ───────────────────────────────────────────────────────────────────────────
  # 5. Deploy to KinD
  #
  # Flow:
  #   a) Spin up a KinD cluster
  #   b) Load the freshly-built image into KinD (no registry pull needed)
  #   c) Install cert-manager (ESO hard dependency)
  #   d) Install External Secrets Operator via Helm
  #   e) Create the namespace
  #   f) Push RICKANDMORTY_DB_SECRET → plain K8s Secret (source for ESO)
  #   g) Helm install the app chart (which creates SecretStore + ExternalSecret)
  #   h) Wait for ESO to sync the ExternalSecret
  #   i) Wait for the Deployment to be fully ready
  #   j) Smoke-test endpoints with curl
  #   k) Run the full integration test suite against the cluster
  # ───────────────────────────────────────────────────────────────────────────
  deploy-kind:
    name: Deploy to KinD
    runs-on: ubuntu-latest
    needs: push-image
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # ── a) Spin up KinD ────────────────────────────────────────────────────
      - name: Create KinD cluster
        uses: helm/kind-action@v1.10.0
        with:
          cluster_name: rickandmorty
          # Single-node config is enough for CI; extraPortMappings expose the
          # app via NodePort so curl and the integration tests can reach it.
          config: |
            kind: Cluster
            apiVersion: kind.x-k8s.io/v1alpha4
            nodes:
              - role: control-plane
                extraPortMappings:
                  - containerPort: 30800
                    hostPort: 8000
                    protocol: TCP

      # ── b) Load the app image into KinD ───────────────────────────────────
      # Avoids a Docker Hub pull; uses the image built in build-and-test.
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build image for KinD (amd64 only, local load)
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.APP_DIR }}
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:kind
          cache-from: type=gha

      - name: Load image into KinD
        run: kind load docker-image ${{ env.IMAGE_NAME }}:kind --name rickandmorty

      # ── c) Install cert-manager (required by ESO) ─────────────────────────
      - name: Install cert-manager
        run: |
          helm repo add jetstack https://charts.jetstack.io --force-update
          helm upgrade --install cert-manager jetstack/cert-manager \
            --namespace cert-manager \
            --create-namespace \
            --set installCRDs=true \
            --wait \
            --timeout 3m

      # ── d) Install External Secrets Operator ──────────────────────────────
      - name: Install External Secrets Operator
        run: |
          helm repo add external-secrets https://charts.external-secrets.io --force-update
          helm upgrade --install external-secrets external-secrets/external-secrets \
            --namespace external-secrets \
            --create-namespace \
            --set installCRDs=true \
            --wait \
            --timeout 3m

      # ── e) Create app namespace ────────────────────────────────────────────
      - name: Create namespace
        run: kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      # ── f) Push raw secret into the cluster ───────────────────────────────
      # RICKANDMORTY_DB_SECRET holds the full secrets.json JSON string, e.g.:
      #   {"host":"postgres","user":"rickandmorty","password":"s3cr3t","dbname":"rickandmorty"}
      # The ESO ExternalSecret reads this K8s Secret via the Kubernetes provider.
      - name: Push db secret to cluster
        env:
          DB_SECRET_JSON: ${{ secrets.RICKANDMORTY_DB_SECRET }}
        run: |
          kubectl create secret generic rickandmorty-db-raw \
            --from-literal=secrets.json="${DB_SECRET_JSON}" \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      # ── g) Deploy PostgreSQL into KinD ────────────────────────────────────
      # The app needs a real Postgres — deploy a minimal one into the cluster.
      - name: Deploy PostgreSQL
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami --force-update
          helm upgrade --install postgres bitnami/postgresql \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --set auth.username=rickandmorty \
            --set auth.password=rickandmorty \
            --set auth.database=rickandmorty \
            --wait \
            --timeout 3m

      # ── h) Helm install the app chart ─────────────────────────────────────
      - name: Helm install rickandmorty-api
        run: |
          helm upgrade --install rickandmorty-api ./helm/rickandmorty-api \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --set image.repository=${{ env.IMAGE_NAME }} \
            --set image.tag=kind \
            --set image.pullPolicy=Never \
            --set service.type=NodePort \
            --set service.nodePort=30800 \
            --set config.log_level=INFO \
            --set externalSecret.secretStoreName=rickandmorty-secret-store \
            --set externalSecret.sourceSecretName=rickandmorty-db-raw \
            --set externalSecret.targetSecretName=rickandmorty-db-secret \
            --set 'dbSecret.host=postgres-postgresql.${{ env.K8S_NAMESPACE }}.svc.cluster.local' \
            --wait \
            --timeout 5m

      # ── i) Wait for ESO to sync the ExternalSecret ────────────────────────
      - name: Wait for ExternalSecret to sync
        run: |
          echo "Waiting for ExternalSecret to reach Ready state..."
          for i in $(seq 1 24); do
            STATUS=$(kubectl get externalsecret rickandmorty-api-db \
              -n ${{ env.K8S_NAMESPACE }} \
              -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "")
            if [ "$STATUS" = "True" ]; then
              echo "ExternalSecret synced successfully."
              break
            fi
            echo "Attempt $i/24 — current status: '${STATUS}'. Retrying in 5s..."
            sleep 5
          done
          # Print full status for debugging regardless
          kubectl get externalsecret -n ${{ env.K8S_NAMESPACE }}

      # ── j) Wait for the Deployment rollout ────────────────────────────────
      - name: Wait for Deployment rollout
        run: |
          kubectl rollout status deployment/rickandmorty-api \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --timeout=3m

      # ── k) Smoke-test endpoints with curl ─────────────────────────────────
      - name: Smoke test — /docs reachable
        run: |
          curl -sf http://localhost:8000/docs > /dev/null && \
            echo "✅ /docs OK" || (echo "❌ /docs FAILED" && exit 1)

      - name: Smoke test — /db-mon?aspect=conn
        run: |
          STATUS=$(curl -sf -o /dev/null -w "%{http_code}" http://localhost:8000/db-mon?aspect=conn)
          echo "Response: $STATUS"
          [ "$STATUS" = "200" ] && echo "✅ DB connection OK" || (echo "❌ DB connection FAILED" && exit 1)

      - name: Smoke test — /db-mon?aspect=records
        run: |
          STATUS=$(curl -sf -o /dev/null -w "%{http_code}" http://localhost:8000/db-mon?aspect=records)
          echo "Response: $STATUS"
          [ "$STATUS" = "200" ] && echo "✅ Records endpoint OK" || (echo "❌ Records endpoint FAILED" && exit 1)

      - name: Smoke test — /data validation (expect 400)
        run: |
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            "http://localhost:8000/data?sort_field=invalid&sort_order=ASC")
          echo "Response: $STATUS"
          [ "$STATUS" = "400" ] && echo "✅ Validation returns 400 OK" || (echo "❌ Unexpected status $STATUS" && exit 1)

      # ── l) Full integration test suite against KinD ───────────────────────
      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Set up Python
        run: uv python install

      - name: Install test dependencies
        working-directory: ${{ env.APP_DIR }}
        run: uv sync --all-extras

      - name: Run integration tests against KinD
        working-directory: ${{ env.APP_DIR }}
        env:
          API_BASE_URL: http://localhost:8000
        run: |
          uv run pytest tests/integration/ \
            --tb=short \
            -v

      # ── Diagnostics on failure ─────────────────────────────────────────────
      - name: Dump pod logs on failure
        if: failure()
        run: |
          echo "=== Pods ==="
          kubectl get pods -n ${{ env.K8S_NAMESPACE }}

          echo "=== ExternalSecret status ==="
          kubectl describe externalsecret -n ${{ env.K8S_NAMESPACE }}

          echo "=== App pod logs ==="
          kubectl logs -l app.kubernetes.io/name=rickandmorty-api \
            -n ${{ env.K8S_NAMESPACE }} --tail=100 || true

          echo "=== ESO controller logs ==="
          kubectl logs -l app.kubernetes.io/name=external-secrets \
            -n external-secrets --tail=50 || true