name: CI/CD Pipeline

on:
  push:
    branches: [main, master, develop]
  pull_request:
    branches: [main, master]

env:
  REGISTRY: docker.io
  IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/rickandmorty-api
  APP_DIR: .
  # Kubernetes namespace used in every kubectl/helm command
  K8S_NAMESPACE: rickandmorty

jobs:
  # ─────────────────────────────────────────────
  # 1. Code Quality
  # ─────────────────────────────────────────────
  lint-and-security:
    name: Lint & Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"

      - name: Set up Python
        run: uv python install

      - name: Install dependencies
        working-directory: ${{ env.APP_DIR }}
        run: uv sync --all-extras

      # Ruff covers both linting and formatting checks
      - name: Lint with Ruff
        working-directory: ${{ env.APP_DIR }}
        run: uv run ruff check . --output-format=github

      - name: Format check with Ruff
        working-directory: ${{ env.APP_DIR }}
        run: uv run ruff format --check .

      # Static type checking
      - name: Type check with mypy
        working-directory: ${{ env.APP_DIR }}
        run: uv run mypy main.py --ignore-missing-imports
        continue-on-error: true   # advisory; flip to false to enforce

      # Security: dependency vulnerabilities
      - name: Security scan with pip-audit
        working-directory: ${{ env.APP_DIR }}
        run: uv run pip-audit

      # Security: source-code patterns (secrets, hardcoded creds, etc.)
      - name: Security scan with Bandit
        working-directory: ${{ env.APP_DIR }}
        run: uv run bandit -r main.py -c pyproject.toml -ll

  # ─────────────────────────────────────────────
  # 2. Unit Tests
  # ─────────────────────────────────────────────
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: lint-and-security

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Set up Python
        run: uv python install

      - name: Install dependencies
        working-directory: ${{ env.APP_DIR }}
        run: uv sync --all-extras

      # Provide dummy config/secret files so the module-level argparse
      # does not fail during import inside the test suite.
      - name: Create dummy config files
        run: |
          mkdir -p tmp
          echo '{"user":"test","password":"test","host":"localhost","dbname":"testdb"}' > tmp/secrets.json
          printf 'log_level: INFO\n' > tmp/config.yaml

      - name: Run unit tests
        working-directory: ${{ env.APP_DIR }}
        env:
          CONFIG_PATH: ../tmp/config.yaml
          SECRET_PATH: ../tmp/secrets.json
        run: |
          uv run pytest tests/unit/ \
            --tb=short \
            -v \
            --cov=main \
            --cov-report=xml \
            --cov-report=term-missing

      - name: Upload coverage report
        uses: codecov/codecov-action@v4
        if: always()
        with:
          files: ${{ env.APP_DIR }}/coverage.xml
          fail_ci_if_error: false

  # ─────────────────────────────────────────────
  # 3. Build & Test Docker Image
  # ─────────────────────────────────────────────
  build-and-test:
    name: Build & Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image (local, no push)
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.APP_DIR }}
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ── Scan the built image for OS/package CVEs ──
      - name: Scan image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_NAME }}:test
          format: table
          exit-code: 1            # fail on CRITICAL vulnerabilities
          severity: CRITICAL
          ignore-unfixed: true

      # ── Spin up the app container for integration tests ──
      - name: Create runtime config files
        run: |
          mkdir -p tmp
          cat > tmp/secrets.json <<'EOF'
          {"user":"testuser","password":"testpass","host":"localhost","dbname":"rickandmorty"}
          EOF
          printf 'log_level: INFO\n' > tmp/config.yaml

      - name: Run application container
        run: |
          docker run -d \
            --name app \
            --network host \
            -v ${{ github.workspace }}/tmp:/tmp/appconfig:ro \
            ${{ env.IMAGE_NAME }}:test \
            --config /tmp/appconfig/config.yaml \
            --secret /tmp/appconfig/secrets.json

      - name: Wait for application to be ready
        run: |
          for i in $(seq 1 30); do
            if curl -sf http://localhost:8000/docs > /dev/null 2>&1; then
              echo "App is up!"
              break
            fi
            echo "Waiting... attempt $i"
            sleep 3
          done

      - name: Install uv (for integration test runner)
        uses: astral-sh/setup-uv@v4

      - name: Set up Python
        run: uv python install

      - name: Install test dependencies
        working-directory: ${{ env.APP_DIR }}
        run: uv sync --all-extras

      - name: Run integration tests
        working-directory: ${{ env.APP_DIR }}
        env:
          API_BASE_URL: http://localhost:8000
          DB_HOST: localhost
          DB_USER: testuser
          DB_PASSWORD: testpass
          DB_NAME: rickandmorty
        run: |
          uv run pytest tests/integration/ \
            --tb=short \
            -v

      - name: Dump container logs on failure
        if: failure()
        run: docker logs app

  # ─────────────────────────────────────────────
  # 4. Push to Docker Hub
  # ─────────────────────────────────────────────
  push-image:
    name: Push to Docker Hub
    runs-on: ubuntu-latest
    needs: build-and-test
    # Only push on commits to the default branch (not on PRs)
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')

    steps:
      #- name: Set current date as environment variable
      #  run: echo "NOW=$(date +'%Y-%m-%d')" >> $GITHUB_ENV

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract Docker metadata (tags & labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: type=raw,value=build-{{date 'YYYYMMDD-HHmm'}}-{{sha}}
          #tags: |
          #  type=sha,prefix=sha-
          #  type=ref,event=branch
          #  type=raw,value=build-${{ env.NOW }},enable=${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' }}

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.APP_DIR }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

# ───────────────────────────────────────────────────────────────────────────
  # 5. Deploy to KinD
  #
  # Why SecretStore and ExternalSecret are applied via kubectl and NOT via Helm:
  # Helm validates all chart resources against the live API server before apply.
  # If the ESO CRDs are not yet registered, Helm fails with:
  #   "no matches for kind ExternalSecret in version external-secrets.io/v1beta1"
  # Solution: keep the Helm chart free of ESO custom resources; apply them
  # with kubectl AFTER explicitly confirming the CRDs are Established.
  #
  # Flow:
  #   a) Write KinD config file and create cluster
  #   b) Build and load app image into KinD
  #   c) Install cert-manager (ESO hard dependency)
  #   d) Install ESO via Helm + wait for CRDs to be Established
  #   e) Create namespace + push raw secret
  #   f) Apply SecretStore and ExternalSecret via kubectl
  #   g) Deploy PostgreSQL
  #   h) Helm install app chart (no ESO kinds — safe to validate)
  #   i) Wait for ESO sync + Deployment rollout
  #   j) Smoke tests + integration tests
  # ───────────────────────────────────────────────────────────────────────────
  deploy-kind:
    name: Deploy to KinD
    runs-on: ubuntu-latest
    needs: push-image
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # ── a) KinD cluster ───────────────────────────────────────────────────
      - name: Write KinD cluster config
        run: |
          cat > /tmp/kind-config.yaml << 'EOF'
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
            - role: control-plane
              extraPortMappings:
                - containerPort: 30800
                  hostPort: 8000
                  protocol: TCP
          EOF

      - name: Create KinD cluster
        uses: helm/kind-action@v1.10.0
        with:
          cluster_name: rickandmorty
          config: /tmp/kind-config.yaml

      # ── b) Build and load app image ───────────────────────────────────────
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build image for KinD (amd64 only, local load)
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.APP_DIR }}
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:kind
          cache-from: type=gha

      - name: Load image into KinD
        run: kind load docker-image ${{ env.IMAGE_NAME }}:kind --name rickandmorty

      # ── c) cert-manager ───────────────────────────────────────────────────
      - name: Install cert-manager
        run: |
          helm repo add jetstack https://charts.jetstack.io --force-update
          helm upgrade --install cert-manager jetstack/cert-manager \
            --namespace cert-manager \
            --create-namespace \
            --set installCRDs=true \
            --wait \
            --timeout 3m

      # ── d) ESO + wait for CRDs ────────────────────────────────────────────
      # Install ESO into the same namespace as the app so its ServiceAccount
      # exists in rickandmorty and can read secrets there without any
      # cross-namespace RBAC. CRDs are cluster-scoped so namespace doesn't
      # affect their availability.
      - name: Create namespace
        run: kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Install External Secrets Operator
        run: |
          helm repo add external-secrets https://charts.external-secrets.io --force-update
          helm upgrade --install external-secrets external-secrets/external-secrets \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --set installCRDs=true \
            --wait \
            --timeout 3m

      # kubectl wait --for=condition=Established confirms the CRD object exists,
      # but the API server's REST discovery cache can still lag behind.
      # The only reliable gate is to poll kubectl api-resources until the
      # SecretStore kind actually appears in the discovery list.
      - name: Wait for ESO CRDs to be Established and discoverable
        run: |
          for crd in \
            externalsecrets.external-secrets.io \
            secretstores.external-secrets.io \
            clustersecretstores.external-secrets.io; do
            echo "Waiting for CRD object: $crd"
            kubectl wait --for=condition=Established crd/$crd --timeout=60s
          done

          echo "Polling until SecretStore appears in API discovery..."
          echo $(kubectl api-resources --api-group=external-secrets.io)
          for i in $(seq 1 30); do
            if kubectl api-resources --api-group=external-secrets.io 2>/dev/null | grep -q "secretstores.*v1beta1"; then
              echo "SecretStore is discoverable after $i attempts."
              break
            fi
            echo "Attempt $i/30 — not yet discoverable, retrying in 5s..."
            sleep 5
          done

          if ! kubectl api-resources --api-group=external-secrets.io 2>/dev/null | grep -q "secretstores.*v1beta1"; then
            echo "ERROR: SecretStore never became discoverable."
            exit 1
          fi

      # ── e) Push raw secret ────────────────────────────────────────────────
      - name: Push db secret to cluster
        env:
          DB_SECRET_JSON: ${{ secrets.RICKANDMORTY_DB_SECRET }}
        run: |
          kubectl create secret generic rickandmorty-db-raw \
            --from-literal=secrets.json="${DB_SECRET_JSON}" \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      # ── f) Apply ESO resources via kubectl (NOT via Helm) ─────────────────
      # ESO ServiceAccount is now in rickandmorty — no cross-namespace RBAC needed.
      - name: Apply SecretStore
        run: |
          kubectl apply -f - <<'EOF'
          apiVersion: external-secrets.io/v1beta1
          kind: SecretStore
          metadata:
            name: rickandmorty-secret-store
            namespace: rickandmorty
          spec:
            provider:
              kubernetes:
                remoteNamespace: rickandmorty
                server:
                  caProvider:
                    type: ConfigMap
                    name: kube-root-ca.crt
                    key: ca.crt
                auth:
                  serviceAccount:
                    name: external-secrets
                    namespace: rickandmorty
          EOF

      - name: Apply ExternalSecret
        run: |
          kubectl apply -f - <<'EOF'
          apiVersion: external-secrets.io/v1beta1
          kind: ExternalSecret
          metadata:
            name: rickandmorty-api-db
            namespace: rickandmorty
          spec:
            refreshInterval: 1h
            secretStoreRef:
              kind: SecretStore
              name: rickandmorty-secret-store
            target:
              name: rickandmorty-db-secret
              creationPolicy: Owner
              template:
                type: Opaque
                data:
                  secrets.json: "{{ .secretsJson }}"
            data:
              - secretKey: secretsJson
                remoteRef:
                  key: rickandmorty-db-raw
                  property: secrets.json
          EOF

      # ── g) PostgreSQL ─────────────────────────────────────────────────────
      - name: Deploy PostgreSQL
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami --force-update
          helm upgrade --install postgres bitnami/postgresql \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --set auth.username=rickandmorty \
            --set auth.password=rickandmorty \
            --set auth.database=rickandmorty \
            --wait \
            --timeout 3m

      # ── h) Helm install app chart (ESO kinds removed — safe to validate) ──
      - name: Helm install rickandmorty-api
        run: |
          helm upgrade --install rickandmorty-api ./helm/rickandmorty-api \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --set image.repository=${{ env.IMAGE_NAME }} \
            --set image.tag=kind \
            --set image.pullPolicy=Never \
            --set service.type=NodePort \
            --set service.nodePort=30800 \
            --set config.log_level=INFO \
            --set externalSecret.targetSecretName=rickandmorty-db-secret \
            --wait \
            --timeout 5m

      # ── i) Wait for ESO sync + rollout ───────────────────────────────────
      - name: Wait for ExternalSecret to sync
        run: |
          for i in $(seq 1 24); do
            STATUS=$(kubectl get externalsecret rickandmorty-api-db \
              -n ${{ env.K8S_NAMESPACE }} \
              -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "")
            if [ "$STATUS" = "True" ]; then
              echo "ExternalSecret synced."
              break
            fi
            echo "Attempt $i/24 — status: '${STATUS}'. Retrying in 5s..."
            sleep 5
          done
          kubectl get externalsecret -n ${{ env.K8S_NAMESPACE }}

      - name: Wait for Deployment rollout
        run: |
          kubectl rollout status deployment/rickandmorty-api \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --timeout=3m

      # ── j) Smoke tests ────────────────────────────────────────────────────
      - name: Smoke test — /docs reachable
        run: |
          curl -sf http://localhost:8000/docs > /dev/null && \
            echo "✅ /docs OK" || (echo "❌ /docs FAILED" && exit 1)

      - name: Smoke test — /db-mon?aspect=conn
        run: |
          STATUS=$(curl -sf -o /dev/null -w "%{http_code}" "http://localhost:8000/db-mon?aspect=conn")
          [ "$STATUS" = "200" ] && echo "✅ DB conn OK" || (echo "❌ DB conn FAILED: $STATUS" && exit 1)

      - name: Smoke test — /db-mon?aspect=records
        run: |
          STATUS=$(curl -sf -o /dev/null -w "%{http_code}" "http://localhost:8000/db-mon?aspect=records")
          [ "$STATUS" = "200" ] && echo "✅ Records OK" || (echo "❌ Records FAILED: $STATUS" && exit 1)

      - name: Smoke test — /data validation (expect 400)
        run: |
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            "http://localhost:8000/data?sort_field=invalid&sort_order=ASC")
          [ "$STATUS" = "400" ] && echo "✅ Validation 400 OK" || (echo "❌ Unexpected: $STATUS" && exit 1)

      # ── Integration tests ─────────────────────────────────────────────────
      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Set up Python
        run: uv python install

      - name: Install test dependencies
        working-directory: ${{ env.APP_DIR }}
        run: uv sync --all-extras

      - name: Run integration tests against KinD
        working-directory: ${{ env.APP_DIR }}
        env:
          API_BASE_URL: http://localhost:8000
        run: |
          uv run pytest tests/integration/ \
            --tb=short \
            -v

      # ── Diagnostics on failure ────────────────────────────────────────────
      - name: Dump logs on failure
        if: failure()
        run: |
          echo "=== Pods ==="
          kubectl get pods -n ${{ env.K8S_NAMESPACE }}

          echo "=== ExternalSecret ==="
          kubectl describe externalsecret -n ${{ env.K8S_NAMESPACE }} || true

          echo "=== App logs ==="
          kubectl logs -l app.kubernetes.io/name=rickandmorty-api \
            -n ${{ env.K8S_NAMESPACE }} --tail=100 || true

          echo "=== ESO logs ==="
          kubectl logs -l app.kubernetes.io/name=external-secrets \
            -n ${{ env.K8S_NAMESPACE }} --tail=50 || true